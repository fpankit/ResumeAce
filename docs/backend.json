{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the application, including their authentication details and role.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity. This typically corresponds to the Firebase Authentication UID."
        },
        "name": {
          "type": "string",
          "description": "The display name of the user."
        },
        "email": {
          "type": "string",
          "description": "The email address of the user.",
          "format": "email"
        },
        "role": {
          "type": "string",
          "description": "The role of the user within the application (e.g., 'student' or 'admin')."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the user account was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "name",
        "email",
        "role",
        "createdAt"
      ]
    },
    "ResumeAnalysis": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ResumeAnalysis",
      "type": "object",
      "description": "Stores the results of an ATS resume analysis performed for a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ResumeAnalysis entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who performed this resume analysis. (Relationship: User 1:N ResumeAnalysis)"
        },
        "originalResumeText": {
          "type": "string",
          "description": "The original resume text submitted by the user for analysis."
        },
        "jobDescription": {
          "type": "string",
          "description": "The job description against which the resume was analyzed."
        },
        "atsScore": {
          "type": "number",
          "description": "The Applicant Tracking System (ATS) compatibility score generated by the AI."
        },
        "matchedKeywords": {
          "type": "array",
          "description": "A list of keywords from the job description that were found in the original resume.",
          "items": {
            "type": "string"
          }
        },
        "missingKeywords": {
          "type": "array",
          "description": "A list of keywords from the job description that were not found in the original resume.",
          "items": {
            "type": "string"
          }
        },
        "improvementSuggestions": {
          "type": "string",
          "description": "AI-generated suggestions for improving the resume's compatibility with the job description."
        },
        "improvedResume": {
          "type": "string",
          "description": "The AI-generated version of the resume, incorporating improvements based on the analysis."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when this resume analysis was performed and saved.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "originalResumeText",
        "jobDescription",
        "atsScore",
        "matchedKeywords",
        "missingKeywords",
        "improvementSuggestions",
        "improvedResume",
        "createdAt"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores individual user profiles. The document ID (`{userId}`) matches the Firebase Authentication UID. Includes denormalized 'role' for quick reference in application logic, but 'admin' role authorization is primarily handled via the '/roles_admin' collection for security rules. Owners can read/write their own profile; Admins can read all profiles."
        }
      },
      {
        "path": "/users/{userId}/resumeAnalyses/{resumeAnalysisId}",
        "definition": {
          "entityName": "ResumeAnalysis",
          "schema": {
            "$ref": "#/backend/entities/ResumeAnalysis"
          },
          "description": "A subcollection storing each ResumeAnalysis document for a specific user. The 'userId' is implicitly part of the path '{userId}', ensuring authorization independence. Users can read/write their own analyses; Admins can read all analyses.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the User who owns this resume analysis."
            },
            {
              "name": "resumeAnalysisId",
              "description": "The unique identifier for a specific resume analysis."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{adminId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Dedicated collection for explicit admin role management using the 'Existence over Content' DBAC pattern. A document's existence at `/roles_admin/{adminId}` indicates that '{adminId}' is an administrator. This is crucial for authorization independence in security rules. The documents themselves can be minimal (e.g., just an empty object) as only their existence matters. Write access should be highly restricted (e.g., to existing admins or specific Cloud Functions).",
          "params": [
            {
              "name": "adminId",
              "description": "The unique identifier (Firebase Auth UID) of an administrator."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to be secure, scalable, and debuggable by adhering to the core design principles and strategy mandates. \n\n**Authorization Independence via Denormalization:**\n1.  **User Profiles (`/users/{userId}`):** User profiles are stored directly at `/users/{userId}`, where `{userId}` is the Firebase Authentication UID. This inherently makes the document owner (`request.auth.uid`) immediately available in the path, achieving authorization independence for user-specific profile data. No `get()` operations are needed to determine ownership.\n2.  **Resume Analyses (`/users/{userId}/resumeAnalyses/{resumeAnalysisId}`):** `ResumeAnalysis` documents are nested as a subcollection under the respective user's document. This design choice is critical for authorization independence. By placing `resumeAnalyses` under `/users/{userId}`, the ownership (`userId`) is directly embedded in the document's path. Consequently, security rules can simply compare `request.auth.uid` with the `{userId}` wildcard in the path to grant access, eliminating the need for `get()` calls to a parent document or to fetch the `userId` field from the `ResumeAnalysis` document itself for authorization. The `userId` field is still present within the `ResumeAnalysis` document for indexing and easier application-level queries, but not relied upon by security rules for ownership checks.\n3.  **Admin Roles (`/roles_admin/{adminId}`):** A separate top-level collection `roles_admin` is used for explicit role-based access control. Admin status is determined by the *existence* of a document at `/roles_admin/{request.auth.uid}`. This pattern (`DBAC - Existence over Content`) is highly independent and robust, allowing a quick and atomic check for admin privileges without relying on `get()` calls to the `users` collection or custom claims.\n\n**Support for QAPs (Queries as Authorization Primitives):**\n1.  **User-specific Data:** For a student user querying their `ResumeAnalysis` documents, they would typically query `/users/$(request.auth.uid)/resumeAnalyses`. The security rules, by enforcing `allow read: if request.auth.uid == userId;`, naturally constrain the `list` operation to only return documents where the path matches the authenticated user's ID. This directly aligns with QAPs, as the client-side query is inherently authorized to access only a subset of data defined by their UID, preventing unauthorized broad `list` operations.\n2.  **Admin Access:** For administrators, the security rules will allow broader `list` access based on their presence in the `/roles_admin` collection (e.g., `allow read: if exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));`). This enables admins to list all users or all resume analyses across all users, while still ensuring that this broad access is explicitly authorized by their role, rather than trying to filter results on the server after an unauthorized broad query."
  }
}